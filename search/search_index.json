{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pyHRMC pyHRMC is a tool designed to aid users in perform Hybrid Reverse Monte Carlo simulations from electron-based scattering. Some key features of the package include: Flexible modeling capabilities, including simulation of slab structures Accurate scattering cross sections for electron scattering Machine-learned potentials to predict structural energies with high accuracy Highly parallelizable architecture for major speedups Resources This code was developed with tools from Simmate . Documentation and information about Simmate can be found at https://simmate.org/ and source code is available at https://github.com/jacksund/simmate. For bugs and other issues, please submit them on Github . Citing pyHRMC License","title":"Home"},{"location":"#welcome-to-pyhrmc","text":"pyHRMC is a tool designed to aid users in perform Hybrid Reverse Monte Carlo simulations from electron-based scattering. Some key features of the package include: Flexible modeling capabilities, including simulation of slab structures Accurate scattering cross sections for electron scattering Machine-learned potentials to predict structural energies with high accuracy Highly parallelizable architecture for major speedups","title":"Welcome to pyHRMC"},{"location":"#resources","text":"This code was developed with tools from Simmate . Documentation and information about Simmate can be found at https://simmate.org/ and source code is available at https://github.com/jacksund/simmate. For bugs and other issues, please submit them on Github .","title":"Resources"},{"location":"#citing-pyhrmc","text":"","title":"Citing pyHRMC"},{"location":"#license","text":"","title":"License"},{"location":"about/","text":"About HRMC Hybrid Reverse Monte Carlo (HRMC) is a computational method stochastically perturbs atomic coordinates to fit a structure to experimental structural data. Typically, this data is a pair distribution function (PDF) that is collected from x-ray, neutron, or electron sources. In particular, electron scattering is advantageous or nanoscale and ultrathin materials because of the high resolution and high scattering cross-section of electrons. As materials become increasingly nanoscale, the ability to experimentally collect scattering information from disordered materials is useful. However, PDFs provide limited information on the atomistic arrangement of atoms. This is where Reverse Monte Carlo (RMC) comes in. In traditional implementations of RMC, the simulation is designed to gradually fit a computed PDF of a cell to an experimental PDF by way of random atomic hops, according to the standard Metropolis Monte Carlo algorithm. While this approach is effective at matching the experimental and computed PDFs, it can fail to produce physically realistic structures. This flaw is due to the stochastic nature of the algorithm, and the limited chemical information that guides the simulation. Often, users specify coordination number and bond angle ranges, minimum bond distances, and more to try to constrain the simulation sufficiently to produce realistic structures. However, these inputs require the user to possess a high degree of understanding about the system that they are trying to model and the accuracy of the simulated structure depends heavily on these parameters. To mitigate the issue of user-selected constraint parameters, HRMC was introduced. In addition to fitting the compute PDF to experimental data, HRMC also includes a Boltzmann-type probability term to account for the energy of the structure. This approach therefore effectively minimizes the structural energy while finding and experimental fit, resulting in more flexible constraints to better allow transition states during atom hopping and has been shown to more accurately reproduce chemically accurate structures. pyHRMC is a Python implementation of this HRMC algorithm, with several added features. Questions or concerns? Contact kme@email.unc.edu","title":"About"},{"location":"about/#about-hrmc","text":"Hybrid Reverse Monte Carlo (HRMC) is a computational method stochastically perturbs atomic coordinates to fit a structure to experimental structural data. Typically, this data is a pair distribution function (PDF) that is collected from x-ray, neutron, or electron sources. In particular, electron scattering is advantageous or nanoscale and ultrathin materials because of the high resolution and high scattering cross-section of electrons. As materials become increasingly nanoscale, the ability to experimentally collect scattering information from disordered materials is useful. However, PDFs provide limited information on the atomistic arrangement of atoms. This is where Reverse Monte Carlo (RMC) comes in. In traditional implementations of RMC, the simulation is designed to gradually fit a computed PDF of a cell to an experimental PDF by way of random atomic hops, according to the standard Metropolis Monte Carlo algorithm. While this approach is effective at matching the experimental and computed PDFs, it can fail to produce physically realistic structures. This flaw is due to the stochastic nature of the algorithm, and the limited chemical information that guides the simulation. Often, users specify coordination number and bond angle ranges, minimum bond distances, and more to try to constrain the simulation sufficiently to produce realistic structures. However, these inputs require the user to possess a high degree of understanding about the system that they are trying to model and the accuracy of the simulated structure depends heavily on these parameters. To mitigate the issue of user-selected constraint parameters, HRMC was introduced. In addition to fitting the compute PDF to experimental data, HRMC also includes a Boltzmann-type probability term to account for the energy of the structure. This approach therefore effectively minimizes the structural energy while finding and experimental fit, resulting in more flexible constraints to better allow transition states during atom hopping and has been shown to more accurately reproduce chemically accurate structures. pyHRMC is a Python implementation of this HRMC algorithm, with several added features. Questions or concerns? Contact kme@email.unc.edu","title":"About HRMC"},{"location":"installation/","text":"Installation pyHRMC is not yet available on conda or pip. For the time being, install the package with the following steps: Create and activate a virtual environment with the required packages. Perform via conda with the command: conda create -n pyHRMC pip python==3.11 conda activate pyHRMC Download a copy of the repository locally. The most recent version of the code can be found at https://github.com/ehrhardtkm/pyHRMC. git clone https://github.com/ehrhardtkm/pyHRMC.git cd pyHRMC Install the package in development mode with pip. pip install -e .","title":"Installation"},{"location":"installation/#installation","text":"pyHRMC is not yet available on conda or pip. For the time being, install the package with the following steps: Create and activate a virtual environment with the required packages. Perform via conda with the command: conda create -n pyHRMC pip python==3.11 conda activate pyHRMC Download a copy of the repository locally. The most recent version of the code can be found at https://github.com/ehrhardtkm/pyHRMC. git clone https://github.com/ehrhardtkm/pyHRMC.git cd pyHRMC Install the package in development mode with pip. pip install -e .","title":"Installation"},{"location":"user_guide/","text":"User Guide Running a simulation with pyHRMC requires several input files that contain calculation parameters, experimental data, and an initial structure configuration. To begin, create a new directory with the following files: - Runfile.py - Your epdf.gr - initial_structure.vasp - LAMMPS input files: o In.lmp o In_init.lmp o In_accept.lmp - FLARE force field model (Optional) All calculation parameters are defined in runfile.py, which instantiates the RMC class before calling the run_rmc() method to perform the simulation. rmc = RMC(experimental_G_csv=str, sigma=float, q_scatter=float, q_temp=float, init_temp=float) The RMC class takes arguments that determine the quench rate of the error and energy constraints. Experimental_G_csv: filename of experiment ePDF sigma: # initial value of sigma, the measure of uncertainty in ePDF data q_scatter: # quench rate for error constraint (rate of decreasing sigma) q_temp: quench rate for energy constraint (rate of decreasing temperature) init_temp: initial temperature, which determines the acceptance probability based on energy constraint To perform a simulation, use the run_rmc() method and further specify simulation parameters and constraints. rmc.run_rmc(num_processes=int, initial_structure=str, keV=int, prdf_args={\u201cbin_size:float}, transformations={\u201cAtomHop\u201d:{}}, validators={args}, max_steps=int) An example for a simulation of amorphous Al2O3 is shown below: from simmate.apps.epdf_rmc.rmc import RMC import multiprocessing if __name__ == \"__main__\": rmc = RMC(experimental_G_csv=\"al2o3_5nm_gr.txt\", sigma = 0.05, q_scatter = 1, q_temp = 0.999999995, init_temp = 1000) rmc.run_rmc( num_processes = 8, initial_structure=\"POSCAR_47A-d33\", keV=200, prdf_args={\"bin_size\": 0.04}, transformations={ # \"ASECoordinatePerturbation\":{}, #simmate version of RattleMutation from ase, rattle_prob auto set to 0.3 \"AtomHop\": {}, # consider adding a second, smaller step size \"max_step\": 0.2 }, validators={ \"SlabThickness\": {\"max_thickness\": 47.4}, \"Coordination\": { \"BulkCoordinationRange\": {\"Al\": {\"Al\" : [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": {\"Al\": {\"Al\": [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 5 } }, max_steps= 1000000, ) Traditional RMC simulations can also be performed with pyHRMC. It\u2019s important to note that traditional RMC is typically less accurate than HRMC, and for this reason, we don\u2019t recommend it. However, it can be useful in some cases, such as when a suitable force field is not available for energy calculations. To run an RMC simulation (with no energy constraint): Required initial files: - runfile.py - your_epdf.gr - initial_structure.vasp In this case, empirical structural constraints are necessary to prevent the Monte Carlo algorithm from producing unphysical configurations. Coordination and distance constraints are available under the Validators class. SlabThickness Coordination: { BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance }","title":"User guide"},{"location":"user_guide/#user-guide","text":"Running a simulation with pyHRMC requires several input files that contain calculation parameters, experimental data, and an initial structure configuration. To begin, create a new directory with the following files: - Runfile.py - Your epdf.gr - initial_structure.vasp - LAMMPS input files: o In.lmp o In_init.lmp o In_accept.lmp - FLARE force field model (Optional) All calculation parameters are defined in runfile.py, which instantiates the RMC class before calling the run_rmc() method to perform the simulation. rmc = RMC(experimental_G_csv=str, sigma=float, q_scatter=float, q_temp=float, init_temp=float) The RMC class takes arguments that determine the quench rate of the error and energy constraints. Experimental_G_csv: filename of experiment ePDF sigma: # initial value of sigma, the measure of uncertainty in ePDF data q_scatter: # quench rate for error constraint (rate of decreasing sigma) q_temp: quench rate for energy constraint (rate of decreasing temperature) init_temp: initial temperature, which determines the acceptance probability based on energy constraint To perform a simulation, use the run_rmc() method and further specify simulation parameters and constraints. rmc.run_rmc(num_processes=int, initial_structure=str, keV=int, prdf_args={\u201cbin_size:float}, transformations={\u201cAtomHop\u201d:{}}, validators={args}, max_steps=int) An example for a simulation of amorphous Al2O3 is shown below: from simmate.apps.epdf_rmc.rmc import RMC import multiprocessing if __name__ == \"__main__\": rmc = RMC(experimental_G_csv=\"al2o3_5nm_gr.txt\", sigma = 0.05, q_scatter = 1, q_temp = 0.999999995, init_temp = 1000) rmc.run_rmc( num_processes = 8, initial_structure=\"POSCAR_47A-d33\", keV=200, prdf_args={\"bin_size\": 0.04}, transformations={ # \"ASECoordinatePerturbation\":{}, #simmate version of RattleMutation from ase, rattle_prob auto set to 0.3 \"AtomHop\": {}, # consider adding a second, smaller step size \"max_step\": 0.2 }, validators={ \"SlabThickness\": {\"max_thickness\": 47.4}, \"Coordination\": { \"BulkCoordinationRange\": {\"Al\": {\"Al\" : [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": {\"Al\": {\"Al\": [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 5 } }, max_steps= 1000000, ) Traditional RMC simulations can also be performed with pyHRMC. It\u2019s important to note that traditional RMC is typically less accurate than HRMC, and for this reason, we don\u2019t recommend it. However, it can be useful in some cases, such as when a suitable force field is not available for energy calculations. To run an RMC simulation (with no energy constraint): Required initial files: - runfile.py - your_epdf.gr - initial_structure.vasp In this case, empirical structural constraints are necessary to prevent the Monte Carlo algorithm from producing unphysical configurations. Coordination and distance constraints are available under the Validators class. SlabThickness Coordination: { BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance }","title":"User Guide"},{"location":"user_guide/nonhybrid_setup/","text":"Non-hybrid simulations (RMC) Traditional RMC simulations can also be performed with pyHRMC. It\u2019s important to note that traditional RMC is typically less accurate than HRMC, and for this reason, we don\u2019t recommend it. However, it can be useful in some cases, such as when a suitable force field is not available for energy calculations. To run an RMC simulation (with no energy constraint), use the following input files: runfile.py your_epdf.gr initial_structure.vasp In this case, empirical structural constraints are necessary to prevent the Monte Carlo algorithm from producing unphysical configurations. Coordination and distance constraints are available under the Validators class.","title":"Non-hybrid simulations"},{"location":"user_guide/nonhybrid_setup/#non-hybrid-simulations-rmc","text":"Traditional RMC simulations can also be performed with pyHRMC. It\u2019s important to note that traditional RMC is typically less accurate than HRMC, and for this reason, we don\u2019t recommend it. However, it can be useful in some cases, such as when a suitable force field is not available for energy calculations. To run an RMC simulation (with no energy constraint), use the following input files: runfile.py your_epdf.gr initial_structure.vasp In this case, empirical structural constraints are necessary to prevent the Monte Carlo algorithm from producing unphysical configurations. Coordination and distance constraints are available under the Validators class.","title":"Non-hybrid simulations (RMC)"},{"location":"user_guide/validator_selection/","text":"pyHRMC.validators Validators are used to impose physical constraints on the Monte Carlo algorithm and enforce the evolution of physically realistic structural configurations. In traditional RMC, these constraints are the sole avenue in imposing \"chemical knowledge\" on the simulation. In HRMC, the need for accurate and restrictive constraints are alleviated because the structure's energy is also used to determine whether to accept or reject a proposed step. Since no set of validators is universally applicable across systems, users must select values that are appropriate for their use case. In the event of performing a bulk HRMC simulation instead of a slab, ... EDIT CODE TO PERMIT BULK SIMULATIONS SlabThickness Coordination: { BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance }","title":"Validator selection"},{"location":"user_guide/validator_selection/#pyhrmcvalidators","text":"Validators are used to impose physical constraints on the Monte Carlo algorithm and enforce the evolution of physically realistic structural configurations. In traditional RMC, these constraints are the sole avenue in imposing \"chemical knowledge\" on the simulation. In HRMC, the need for accurate and restrictive constraints are alleviated because the structure's energy is also used to determine whether to accept or reject a proposed step. Since no set of validators is universally applicable across systems, users must select values that are appropriate for their use case. In the event of performing a bulk HRMC simulation instead of a slab, ... EDIT CODE TO PERMIT BULK SIMULATIONS SlabThickness Coordination: { BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance }","title":"pyHRMC.validators"},{"location":"user_guide/getting_started/lammps_input/","text":"LAMMPS input and potential files In pyHRMC, the structural energy is computed for every atom hop with LAMMPS. LAMMPS requires input files that act as a \"to-do list\" for the program, including information about the structure, desired computes, and running LAMMPS. For more detailed documentation, please refer to the official LAMMPS documentation . Curently, pyHRMC requires three input files. In the future, this wil be modified to reduce the number of files to one. in.lmp Four sections are required for the in.lmp file: Initialization, Atom groups, Compute and outputs, and Run. Initialization: This is used to select the units for LAMMPS to use, read in the structure, and specify potential parameters. Because pyHRMC will automatically write a structure data file in the LAMMPS format, always include the following line: read_data data.lmp Additionally, is using a potential model trained from FLARE, follow instructions in their documentation to include this in the input script. pair_style flare pair_coeff * * lmp.flare Atom groups: Add the mass and element names of the elements in the cell. The numbering of the atom types will follow the order of atoms in the original structure file mass {atom_type} {float} group {element_name} type {atom_type} Compute and outputs thermo 1 thermo_style custom step pe ke etotal Run: Run the LAMMPS code for 0 timesteps, meaning that it will only perform the desired computes and not perform any molecular dynamics # Run the simulation run 0 write_data out4.txt nocoeff nofix Example # Initialization atom_style atomic units metal boundary p p p atom_modify sort 0 0.0 newton on read_data data.lmp ### interactions pair_style flare pair_coeff * * s_lmp.flare # Atom groups mass 1 26.981539 mass 2 15.9994 group Al type 1 group O type 2 #Compute and outputs compute unc all flare/std/atom s_L_inv_lmp.flare s_sparse_desc_lmp.flare compute MaxUnc all reduce max c_unc thermo 1 thermo_style custom step pe ke etotal # Run the simulation run 0 write_data out4.txt nocoeff nofix in_init.lmp This script requires additional lines to save each step in a file called \"last_step.txt\" to allow LAMMPS to restart at the appropriate timestep. Add the following lines before the run command in the original in.lmp script: # Save the final timestep to a file variable last_step equal \"step\" shell echo ${last_step} > last_step.txt in_accept.lmp This script requires an additional line to read in the current timestep of the simulation. Add the following line before the run command in the original in.lmp script: # Read the last timestep from the file reset_timestep ${last_step}","title":"LAMMPS input files"},{"location":"user_guide/getting_started/lammps_input/#lammps-input-and-potential-files","text":"In pyHRMC, the structural energy is computed for every atom hop with LAMMPS. LAMMPS requires input files that act as a \"to-do list\" for the program, including information about the structure, desired computes, and running LAMMPS. For more detailed documentation, please refer to the official LAMMPS documentation . Curently, pyHRMC requires three input files. In the future, this wil be modified to reduce the number of files to one.","title":"LAMMPS input and potential files"},{"location":"user_guide/getting_started/lammps_input/#inlmp","text":"Four sections are required for the in.lmp file: Initialization, Atom groups, Compute and outputs, and Run. Initialization: This is used to select the units for LAMMPS to use, read in the structure, and specify potential parameters. Because pyHRMC will automatically write a structure data file in the LAMMPS format, always include the following line: read_data data.lmp Additionally, is using a potential model trained from FLARE, follow instructions in their documentation to include this in the input script. pair_style flare pair_coeff * * lmp.flare Atom groups: Add the mass and element names of the elements in the cell. The numbering of the atom types will follow the order of atoms in the original structure file mass {atom_type} {float} group {element_name} type {atom_type} Compute and outputs thermo 1 thermo_style custom step pe ke etotal Run: Run the LAMMPS code for 0 timesteps, meaning that it will only perform the desired computes and not perform any molecular dynamics # Run the simulation run 0 write_data out4.txt nocoeff nofix","title":"in.lmp"},{"location":"user_guide/getting_started/lammps_input/#example","text":"# Initialization atom_style atomic units metal boundary p p p atom_modify sort 0 0.0 newton on read_data data.lmp ### interactions pair_style flare pair_coeff * * s_lmp.flare # Atom groups mass 1 26.981539 mass 2 15.9994 group Al type 1 group O type 2 #Compute and outputs compute unc all flare/std/atom s_L_inv_lmp.flare s_sparse_desc_lmp.flare compute MaxUnc all reduce max c_unc thermo 1 thermo_style custom step pe ke etotal # Run the simulation run 0 write_data out4.txt nocoeff nofix","title":"Example"},{"location":"user_guide/getting_started/lammps_input/#in_initlmp","text":"This script requires additional lines to save each step in a file called \"last_step.txt\" to allow LAMMPS to restart at the appropriate timestep. Add the following lines before the run command in the original in.lmp script: # Save the final timestep to a file variable last_step equal \"step\" shell echo ${last_step} > last_step.txt","title":"in_init.lmp"},{"location":"user_guide/getting_started/lammps_input/#in_acceptlmp","text":"This script requires an additional line to read in the current timestep of the simulation. Add the following line before the run command in the original in.lmp script: # Read the last timestep from the file reset_timestep ${last_step}","title":"in_accept.lmp"},{"location":"user_guide/getting_started/outputs/","text":"Outputs Once the HRMC simulation is started, pyHRMC will generate several files that it will continuously update during the simulation. These files contain data regarding the simulation and can be used for post-processing: error_plotting.txt output.vasp XDATCAR Additionally, several files are created and used by HRMC during the simulation, but do not provide useful information ot the user: {int}.lmp last_step.txt out4.txt","title":"Understanding outputs"},{"location":"user_guide/getting_started/outputs/#outputs","text":"Once the HRMC simulation is started, pyHRMC will generate several files that it will continuously update during the simulation. These files contain data regarding the simulation and can be used for post-processing: error_plotting.txt output.vasp XDATCAR Additionally, several files are created and used by HRMC during the simulation, but do not provide useful information ot the user: {int}.lmp last_step.txt out4.txt","title":"Outputs"},{"location":"user_guide/getting_started/required_files/","text":"Getting Started Input files Running a simulation with pyHRMC requires several input files that contain calculation parameters, experimental data, and an initial structure configuration. To begin, create a new directory with the following files: runfile.py your_epdf.gr initial_structure.vasp LAMMPS input files: in.lmp in_init.lmp in_accept.lmp FLARE force field model (Optional)","title":"Required files"},{"location":"user_guide/getting_started/required_files/#getting-started","text":"","title":"Getting Started"},{"location":"user_guide/getting_started/required_files/#input-files","text":"Running a simulation with pyHRMC requires several input files that contain calculation parameters, experimental data, and an initial structure configuration. To begin, create a new directory with the following files: runfile.py your_epdf.gr initial_structure.vasp LAMMPS input files: in.lmp in_init.lmp in_accept.lmp FLARE force field model (Optional)","title":"Input files"},{"location":"user_guide/getting_started/runfile_setup/","text":"Runfile setup All calculation parameters are defined in runfile.py, which instantiates the RMC class before calling the run_rmc() method to perform the simulation. A runfile should begin with necessary imports: from pyHRMC.core.rmc import RMC import multiprocessing To run a simulation, the user must first instantiate the RMC class with the required arguments. These arguments determine the quench rate of the error and energy constraints. rmc = RMC(experimental_G_csv=str, sigma=float, q_scatter=float, q_temp=float, init_temp=float) experimental_G_csv = filename of experiment ePDF sigma = initial value of sigma, the measure of uncertainty in ePDF data q_scatter = quench rate for error constraint (rate of decreasing sigma) q_temp = quench rate for energy constraint (rate of decreasing temperature) init_temp = initial temperature, which determines the acceptance probability based on energy constraint To perform a simulation, use the run_rmc() method and further specify simulation parameters and constraints. rmc.run_rmc(num_processes=int, initial_structure=str, keV=int, prdf_args={\u201cbin_size:float}, transformations={\u201cAtomHop\u201d:{}}, validators={args}, max_steps=int) num_processes = the number of processes to use in the simulation. If a serial simulation is desired, set to 1. initial_structure = the filename of the structure file to use as an initial configuration. This file must be in a POSCAR/VASP format. The structure should have the correct stoichiometry, sincve HRMC does not affect the composition of the structure. keV = the accelerating voltage of the electron microsope used to capture scattering data prdf_args bin_size: the bin size of the computed PDFs, in angstroms. Default is 0.04 angstroms. transformations AtomHop: currently the only kind of transformation available in pyHRMC. This transformation creates a spherical grid of radius 1 Angstrom around an atom and selects a cell within the grid randomly. The coordinates of the selected cell are treated as the new coordinates of the atom. This transformer only moves one atom at a time, but this action can be parallelized for major speedups and yield structures with multiple moved atoms in a single step. validators = details on available validators can be found on the Validator selection page. SlabThickness Coordination BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance max_steps = maximum number of steps to perform in the simulation. If running in parallel, note that all atom transformations performed in parallel will be considered as a single step. Example An example runfile.py for a simulation of amorphous Al2O3 is shown below: from pyHRMC.core.rmc import RMC import multiprocessing if __name__ == \"__main__\": rmc = RMC(experimental_G_csv=\"al2o3_5nm_gr.txt\", sigma = 0.05, q_scatter = 1, q_temp = 0.999999995, init_temp = 1000) rmc.run_rmc( num_processes = 8, initial_structure=\"POSCAR_47A-d33\", keV=200, prdf_args={\"bin_size\": 0.04}, transformations={ \"AtomHop\": {}, # consider adding a second, smaller step size \"max_step\": 0.2 }, validators={ \"SlabThickness\": {\"max_thickness\": 47.4}, \"Coordination\": { \"BulkCoordinationRange\": {\"Al\": {\"Al\" : [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": {\"Al\": {\"Al\": [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 5 } }, max_steps= 1000000, )","title":"Runfile setup"},{"location":"user_guide/getting_started/runfile_setup/#runfile-setup","text":"All calculation parameters are defined in runfile.py, which instantiates the RMC class before calling the run_rmc() method to perform the simulation. A runfile should begin with necessary imports: from pyHRMC.core.rmc import RMC import multiprocessing To run a simulation, the user must first instantiate the RMC class with the required arguments. These arguments determine the quench rate of the error and energy constraints. rmc = RMC(experimental_G_csv=str, sigma=float, q_scatter=float, q_temp=float, init_temp=float) experimental_G_csv = filename of experiment ePDF sigma = initial value of sigma, the measure of uncertainty in ePDF data q_scatter = quench rate for error constraint (rate of decreasing sigma) q_temp = quench rate for energy constraint (rate of decreasing temperature) init_temp = initial temperature, which determines the acceptance probability based on energy constraint To perform a simulation, use the run_rmc() method and further specify simulation parameters and constraints. rmc.run_rmc(num_processes=int, initial_structure=str, keV=int, prdf_args={\u201cbin_size:float}, transformations={\u201cAtomHop\u201d:{}}, validators={args}, max_steps=int) num_processes = the number of processes to use in the simulation. If a serial simulation is desired, set to 1. initial_structure = the filename of the structure file to use as an initial configuration. This file must be in a POSCAR/VASP format. The structure should have the correct stoichiometry, sincve HRMC does not affect the composition of the structure. keV = the accelerating voltage of the electron microsope used to capture scattering data prdf_args bin_size: the bin size of the computed PDFs, in angstroms. Default is 0.04 angstroms. transformations AtomHop: currently the only kind of transformation available in pyHRMC. This transformation creates a spherical grid of radius 1 Angstrom around an atom and selects a cell within the grid randomly. The coordinates of the selected cell are treated as the new coordinates of the atom. This transformer only moves one atom at a time, but this action can be parallelized for major speedups and yield structures with multiple moved atoms in a single step. validators = details on available validators can be found on the Validator selection page. SlabThickness Coordination BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance max_steps = maximum number of steps to perform in the simulation. If running in parallel, note that all atom transformations performed in parallel will be considered as a single step.","title":"Runfile setup"},{"location":"user_guide/getting_started/runfile_setup/#example","text":"An example runfile.py for a simulation of amorphous Al2O3 is shown below: from pyHRMC.core.rmc import RMC import multiprocessing if __name__ == \"__main__\": rmc = RMC(experimental_G_csv=\"al2o3_5nm_gr.txt\", sigma = 0.05, q_scatter = 1, q_temp = 0.999999995, init_temp = 1000) rmc.run_rmc( num_processes = 8, initial_structure=\"POSCAR_47A-d33\", keV=200, prdf_args={\"bin_size\": 0.04}, transformations={ \"AtomHop\": {}, # consider adding a second, smaller step size \"max_step\": 0.2 }, validators={ \"SlabThickness\": {\"max_thickness\": 47.4}, \"Coordination\": { \"BulkCoordinationRange\": {\"Al\": {\"Al\" : [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": {\"Al\": {\"Al\": [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 5 } }, max_steps= 1000000, )","title":"Example"}]}