{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to pyHRMC! pyHRMC is a tool designed to aid users in perform Hybrid Reverse Monte Carlo simulations from electron-based scattering. Some key features of the package include: Flexible modeling capabilities, including simulation of slab structures Accurate scattering cross sections for electron scattering Machine-learned potentials to predict structural energies with high accuracy Highly parallelizable architecture for major speedups Getting started This site provides the official documentation for pyHRMC. To install pyHRMC and start your first simulation, please see the Installation steps. About HRMC Hybrid Reverse Monte Carlo (HRMC) is a computational method that stochastically perturbs the atomic configuration of a structure to fit its configuration to experimental structural data. Typically, this data is a pair distribution function (PDF) that is collected from x-ray, neutron, or electron sources. In particular, electron scattering is advantageous for nanoscale and ultrathin materials because of the high spatial resolution and larger scattering cross-section of electrons. As materials become increasingly nanoscale, the ability to experimentally collect scattering information from disordered materials is useful. However, PDFs provide limited information on the atomistic arrangement of atoms. This is where Reverse Monte Carlo (RMC) comes in. In traditional implementations of RMC, the simulation is designed to gradually fit a computed PDF of a cell to an experimental PDF by way of random atomic hops, according to the standard Metropolis Monte Carlo algorithm. While this approach is effective at matching the experimental and computed PDFs, it can fail to produce physically realistic structures. This flaw is due to the stochastic nature of the algorithm, and the limited chemical information that guides the simulation. Often, users specify coordination number and bond angle ranges, minimum bond distances, and more to try to constrain the simulation sufficiently to produce realistic structures. However, these inputs require the user to possess a high degree of understanding about the system that they are trying to model and the accuracy of the simulated structure depends heavily on these parameters. To mitigate the issue of user-selected constraint parameters, HRMC was introduced. In addition to fitting the compute PDF to experimental data, HRMC also includes a Boltzmann-type probability term to account for the energy of the structure. This approach therefore effectively minimizes the structural energy while finding and experimental fit, resulting in more flexible constraints to better allow transition states during atom hopping and has been shown to more accurately reproduce chemically accurate structures. pyHRMC is a Python implementation of this HRMC algorithm, with several added features. Resources This code was developed with tools from pymatgen . For bugs and other issues, please submit them on Github . Questions or concerns? Contact kme@email.unc.edu Citing pyHRMC We are currently preparing a publication. This section will be updated when the publication is released. Compatibility pyHRMC is currently comptability with Python <= 3.11. License pyHRMC is licensed under a 3-clause BSD license. Portions of the code were borrowed from pymatgen, matminer, and Simmate, which are also licensed under MIT and BSD-style licenses. For details, please see LICENSE . References","title":"Home"},{"location":"#welcome-to-pyhrmc","text":"pyHRMC is a tool designed to aid users in perform Hybrid Reverse Monte Carlo simulations from electron-based scattering. Some key features of the package include: Flexible modeling capabilities, including simulation of slab structures Accurate scattering cross sections for electron scattering Machine-learned potentials to predict structural energies with high accuracy Highly parallelizable architecture for major speedups","title":"Welcome to pyHRMC!"},{"location":"#getting-started","text":"This site provides the official documentation for pyHRMC. To install pyHRMC and start your first simulation, please see the Installation steps.","title":"Getting started"},{"location":"#about-hrmc","text":"Hybrid Reverse Monte Carlo (HRMC) is a computational method that stochastically perturbs the atomic configuration of a structure to fit its configuration to experimental structural data. Typically, this data is a pair distribution function (PDF) that is collected from x-ray, neutron, or electron sources. In particular, electron scattering is advantageous for nanoscale and ultrathin materials because of the high spatial resolution and larger scattering cross-section of electrons. As materials become increasingly nanoscale, the ability to experimentally collect scattering information from disordered materials is useful. However, PDFs provide limited information on the atomistic arrangement of atoms. This is where Reverse Monte Carlo (RMC) comes in. In traditional implementations of RMC, the simulation is designed to gradually fit a computed PDF of a cell to an experimental PDF by way of random atomic hops, according to the standard Metropolis Monte Carlo algorithm. While this approach is effective at matching the experimental and computed PDFs, it can fail to produce physically realistic structures. This flaw is due to the stochastic nature of the algorithm, and the limited chemical information that guides the simulation. Often, users specify coordination number and bond angle ranges, minimum bond distances, and more to try to constrain the simulation sufficiently to produce realistic structures. However, these inputs require the user to possess a high degree of understanding about the system that they are trying to model and the accuracy of the simulated structure depends heavily on these parameters. To mitigate the issue of user-selected constraint parameters, HRMC was introduced. In addition to fitting the compute PDF to experimental data, HRMC also includes a Boltzmann-type probability term to account for the energy of the structure. This approach therefore effectively minimizes the structural energy while finding and experimental fit, resulting in more flexible constraints to better allow transition states during atom hopping and has been shown to more accurately reproduce chemically accurate structures. pyHRMC is a Python implementation of this HRMC algorithm, with several added features.","title":"About HRMC"},{"location":"#resources","text":"This code was developed with tools from pymatgen . For bugs and other issues, please submit them on Github . Questions or concerns? Contact kme@email.unc.edu","title":"Resources"},{"location":"#citing-pyhrmc","text":"We are currently preparing a publication. This section will be updated when the publication is released.","title":"Citing pyHRMC"},{"location":"#compatibility","text":"pyHRMC is currently comptability with Python <= 3.11.","title":"Compatibility"},{"location":"#license","text":"pyHRMC is licensed under a 3-clause BSD license. Portions of the code were borrowed from pymatgen, matminer, and Simmate, which are also licensed under MIT and BSD-style licenses. For details, please see LICENSE .","title":"License"},{"location":"#references","text":"","title":"References"},{"location":"background_theory/","text":"Theory Monte Carlo and loss function The H/RMC algorithm employs the Metropolis Markov chain Monte Carlo method to stochastically sample atomistic configurations of a structure. The simulations converge by minimizing a loss function, which follows the general form: \\[ \\chi^{2}_{total} = \\sum_{i}^{n} \\sum_{j} \\frac{(A_{i}(j)_{target} - A_{i}(j)_{calc})^{2}} {W_{i}} . \\] Here, the total loss \\(\\chi^{2}_{total}\\) is summed over the n constraints that guide the simulation. Each term in the loss function represents a squared difference between the calculated value \\(A_{calc}\\) and the target value \\(A_{target}\\) , scaled by a weight term \\(W_{i}\\) . The number of terms in this function depends on the constraints that are defined by the user. Typically, in RMC simulations, this loss function includes an error term that fits the calculated pair distribution function (PDF) to experimental PDF data \\[ \\chi^{2}_{error} = \\sum_{i}^{n_{bin}}\\frac{(G(r_{i})_{target} - G(r_{i})_{calc})^{2}} {\\sigma_{}} . \\] where the squared difference between the experimental/target PDF \\(G(r)_{target}\\) and the calculated PDF \\(G(r)_{calc}\\) of the Monte Carlo structure is scaled with \\(\\sigma\\) , the experimental error that acts as the weight term, and is summed over \\(n_{bin}\\) , the number of bins of \\(G(r)_{target}\\) . In pyHRMC, the PDF is always assumed to be the electron pair distribution function (ePDF). This distinction is critical because the scattering cross-sections used to calculate the theoretical electron scattering\u2014and, consequently, the PDF\u2014depend on the ePDF of the simulated structure. While RMC is effective at matching a structure's calculated ePDF to experimental data, it cannot produce a unique solution. In other words, RMC may arrive at one of many different atomistic configurations can produce approximately the same ePDF. . This ambiguity can be somewhat mitigated by choosing simulation cells large enough to yield a statistically robust distribution of coordination environments. However, under-constrained RMC simulations may still produce unrealistic configurations. Hybrid Reverse Monte Carlo (HRMC) To address this limitation, HRMC was introduced by Opletal et al. in 2002 (see ref 1). In HRMC, an additional energy term is included in the total loss function, leading to the following form: \\[ \\chi^{2}_{total} = \\chi^{2}_{error} + \\frac { \\Delta E} {k_{B}T} \\] Similar to the error term, the energy term is scaled by a temperature variable (T). This addition results in a Boltzmann-type probability distribution, where the algorithm may accept a step even when the energy loss term increases. BUG The program will always accept the proposed Monte Carlo step if the new loss value \\(\\chi^{2}_{new}\\) is less than old loss value \\(\\chi^{2}_{old}\\) . Otherwise, the probability of accepting a move is: \\[ P = e^{\\chi^{2}_{old} - \\chi^{2}_{new}} \\] Quench schemes As noted above, the weight term in each loss function affects the Boltzmann-type probability distribution of accepting a \"worse\" step. In traditional RMC, where the PDF error term is the sole contributor to the loss function \\(\\chi^{2}_{total}\\) , this weight \\(\\sigma\\) is typically kept static throughout the simulation. However, initializing the simulation with greater weight terms and gradually reducing them can help optimize convergence. This approach allows the structure to explore a broader structural space early on while still refining toward a low loss value as the simulation progresses. This following quenching scheme was introduced by Opletal et al. and has been implemented in pyHRMC: \\[ T_{n+1} = T_{n} * q_{T}^{n} \\] \\[ \\sigma_{n+1} = \\sigma_{n} * q_{\\sigma}^{n} , \\] where n is the number of steps in millions, and q is a quenching parameter between 0-1. Because H/RMC is performed over millions of steps and gradual quenching is necessary for proper convergence, q is typically very close to 1. When selecting values for these quenching parameters in pyHRMC, note the distinction between a step and an iteration . Quenching will occur after each iteration , so greater parallelization will result in a slightly coarser quenching scheme. For further details and examples in the literature, we suggest the following references: Opletal, G., Petersen, T., O\u2019Malley, B., Snook, I., McCulloch, D. G., Marks, N. A., & Yarovsky, I. Hybrid approach for generating realistic amorphous carbon structure using metropolis and reverse Monte Carlo. Molecular Simulation, 2002, 28(10\u201311), 927\u2013938. https://doi.org/10.1080/089270204000002584 G. Opletal, T.C. Petersen, B. O'Malley, I.K. Snook, D.G. McCulloch, I. Yarovsky. HRMC: Hybrid Reverse Monte Carlo method with silicon and carbon potentials. Comput. Phys. Commun., 2008, 178 (10), 777-787. https://doi.org/10.1016/j.cpc.2007.12.007. Amir H. Farmahini, Suresh K. Bhatia. Hybrid Reverse Monte Carlo simulation of amorphous carbon: Distinguishing between competing structures obtained using different modeling protocols. Carbon, 2015, 83, 53-70. https://doi.org/10.1016/j.carbon.2014.11.013.","title":"Theory"},{"location":"background_theory/#theory","text":"","title":"Theory"},{"location":"background_theory/#monte-carlo-and-loss-function","text":"The H/RMC algorithm employs the Metropolis Markov chain Monte Carlo method to stochastically sample atomistic configurations of a structure. The simulations converge by minimizing a loss function, which follows the general form: \\[ \\chi^{2}_{total} = \\sum_{i}^{n} \\sum_{j} \\frac{(A_{i}(j)_{target} - A_{i}(j)_{calc})^{2}} {W_{i}} . \\] Here, the total loss \\(\\chi^{2}_{total}\\) is summed over the n constraints that guide the simulation. Each term in the loss function represents a squared difference between the calculated value \\(A_{calc}\\) and the target value \\(A_{target}\\) , scaled by a weight term \\(W_{i}\\) . The number of terms in this function depends on the constraints that are defined by the user. Typically, in RMC simulations, this loss function includes an error term that fits the calculated pair distribution function (PDF) to experimental PDF data \\[ \\chi^{2}_{error} = \\sum_{i}^{n_{bin}}\\frac{(G(r_{i})_{target} - G(r_{i})_{calc})^{2}} {\\sigma_{}} . \\] where the squared difference between the experimental/target PDF \\(G(r)_{target}\\) and the calculated PDF \\(G(r)_{calc}\\) of the Monte Carlo structure is scaled with \\(\\sigma\\) , the experimental error that acts as the weight term, and is summed over \\(n_{bin}\\) , the number of bins of \\(G(r)_{target}\\) . In pyHRMC, the PDF is always assumed to be the electron pair distribution function (ePDF). This distinction is critical because the scattering cross-sections used to calculate the theoretical electron scattering\u2014and, consequently, the PDF\u2014depend on the ePDF of the simulated structure. While RMC is effective at matching a structure's calculated ePDF to experimental data, it cannot produce a unique solution. In other words, RMC may arrive at one of many different atomistic configurations can produce approximately the same ePDF. . This ambiguity can be somewhat mitigated by choosing simulation cells large enough to yield a statistically robust distribution of coordination environments. However, under-constrained RMC simulations may still produce unrealistic configurations.","title":"Monte Carlo and loss function"},{"location":"background_theory/#hybrid-reverse-monte-carlo-hrmc","text":"To address this limitation, HRMC was introduced by Opletal et al. in 2002 (see ref 1). In HRMC, an additional energy term is included in the total loss function, leading to the following form: \\[ \\chi^{2}_{total} = \\chi^{2}_{error} + \\frac { \\Delta E} {k_{B}T} \\] Similar to the error term, the energy term is scaled by a temperature variable (T). This addition results in a Boltzmann-type probability distribution, where the algorithm may accept a step even when the energy loss term increases. BUG The program will always accept the proposed Monte Carlo step if the new loss value \\(\\chi^{2}_{new}\\) is less than old loss value \\(\\chi^{2}_{old}\\) . Otherwise, the probability of accepting a move is: \\[ P = e^{\\chi^{2}_{old} - \\chi^{2}_{new}} \\]","title":"Hybrid Reverse Monte Carlo (HRMC)"},{"location":"background_theory/#quench-schemes","text":"As noted above, the weight term in each loss function affects the Boltzmann-type probability distribution of accepting a \"worse\" step. In traditional RMC, where the PDF error term is the sole contributor to the loss function \\(\\chi^{2}_{total}\\) , this weight \\(\\sigma\\) is typically kept static throughout the simulation. However, initializing the simulation with greater weight terms and gradually reducing them can help optimize convergence. This approach allows the structure to explore a broader structural space early on while still refining toward a low loss value as the simulation progresses. This following quenching scheme was introduced by Opletal et al. and has been implemented in pyHRMC: \\[ T_{n+1} = T_{n} * q_{T}^{n} \\] \\[ \\sigma_{n+1} = \\sigma_{n} * q_{\\sigma}^{n} , \\] where n is the number of steps in millions, and q is a quenching parameter between 0-1. Because H/RMC is performed over millions of steps and gradual quenching is necessary for proper convergence, q is typically very close to 1. When selecting values for these quenching parameters in pyHRMC, note the distinction between a step and an iteration . Quenching will occur after each iteration , so greater parallelization will result in a slightly coarser quenching scheme. For further details and examples in the literature, we suggest the following references: Opletal, G., Petersen, T., O\u2019Malley, B., Snook, I., McCulloch, D. G., Marks, N. A., & Yarovsky, I. Hybrid approach for generating realistic amorphous carbon structure using metropolis and reverse Monte Carlo. Molecular Simulation, 2002, 28(10\u201311), 927\u2013938. https://doi.org/10.1080/089270204000002584 G. Opletal, T.C. Petersen, B. O'Malley, I.K. Snook, D.G. McCulloch, I. Yarovsky. HRMC: Hybrid Reverse Monte Carlo method with silicon and carbon potentials. Comput. Phys. Commun., 2008, 178 (10), 777-787. https://doi.org/10.1016/j.cpc.2007.12.007. Amir H. Farmahini, Suresh K. Bhatia. Hybrid Reverse Monte Carlo simulation of amorphous carbon: Distinguishing between competing structures obtained using different modeling protocols. Carbon, 2015, 83, 53-70. https://doi.org/10.1016/j.carbon.2014.11.013.","title":"Quench schemes"},{"location":"installation/","text":"Installation Prior to installing pyHRMC, LAMMPS must be installed and built in serial. Additionally, if using a FLARE potential, LAMMPS must be compiled with FLARE. Instructions for these steps can be found at these links: https://docs.lammps.org/Install.html https://mir-group.github.io/flare/installation/lammps.html To install pyHRMC, first create a virtual environment with the required packages. You can perform this via conda with the commands: conda create -n pyHRMC pip python==3.11 conda activate pyHRMC Installation can then be performed in the new environment. pyHRMC is not yet available on conda, but is available on PyPi for pip install : pip install pyhrmc Alternatively, if users desire to modify the code from their own needs, we recommend the following steps instead: Create an environment: conda create -n pyHRMC pip python==3.11 conda activate pyHRMC Download a copy of the repository locally. The most recent version of the code can be found at https://github.com/ehrhardtkm/pyHRMC. git clone https://github.com/ehrhardtkm/pyHRMC.git cd pyHRMC Install the package in development mode with pip. pip install -e . Testing To verify that pyHRMC is correctly installed, you can run the unit tests that are available in the tests/ directory and implemented with pytest. Prior to testing, ensure that you have both LAMMPS and FLARE installed to your machine. Otherwise, the HRMC test will fail. If you do not intend on using the HRMC function and are only interested in testing the RMC function, you can disregard this error and only check to see if the test succeeds when Hybrid = False . From within the pyhrmc folder, run the following commands: pip install pytest cd tests pytest","title":"Installation"},{"location":"installation/#installation","text":"Prior to installing pyHRMC, LAMMPS must be installed and built in serial. Additionally, if using a FLARE potential, LAMMPS must be compiled with FLARE. Instructions for these steps can be found at these links: https://docs.lammps.org/Install.html https://mir-group.github.io/flare/installation/lammps.html To install pyHRMC, first create a virtual environment with the required packages. You can perform this via conda with the commands: conda create -n pyHRMC pip python==3.11 conda activate pyHRMC Installation can then be performed in the new environment. pyHRMC is not yet available on conda, but is available on PyPi for pip install : pip install pyhrmc Alternatively, if users desire to modify the code from their own needs, we recommend the following steps instead: Create an environment: conda create -n pyHRMC pip python==3.11 conda activate pyHRMC Download a copy of the repository locally. The most recent version of the code can be found at https://github.com/ehrhardtkm/pyHRMC. git clone https://github.com/ehrhardtkm/pyHRMC.git cd pyHRMC Install the package in development mode with pip. pip install -e .","title":"Installation"},{"location":"installation/#testing","text":"To verify that pyHRMC is correctly installed, you can run the unit tests that are available in the tests/ directory and implemented with pytest. Prior to testing, ensure that you have both LAMMPS and FLARE installed to your machine. Otherwise, the HRMC test will fail. If you do not intend on using the HRMC function and are only interested in testing the RMC function, you can disregard this error and only check to see if the test succeeds when Hybrid = False . From within the pyhrmc folder, run the following commands: pip install pytest cd tests pytest","title":"Testing"},{"location":"user_guide/bulk_vs_slab/","text":"Bulk vs slab simulations pyHRMC is designed to handle bulk cells or slab cells in a vacuum. While the package will automatically detect the cell type and handle periodic boundary conditions, several considerations and limitations exist. For a slab cell, pyHRMC assumes that the vacuum space above and below the cell exist in the z-direction, and that the structure extends fully to the cell boundaries in the x and y directions. Additionally, the slab must be orthogonal to the z-axis for the package to correctly detect the cell thickness. When running a slab cell simulation and employing the Validators.coordination constraint, be sure to set constraints for SurfaceCoordinationRange and SurfaceDistance in addition to BulkCoordinationRange . For example: \"Coordination\": { \"BulkCoordinationRange\": { \"Al\": {\"Al\" : [0, 2], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": { \"Al\": {\"Al\": [0, 2], \"O\": [1, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 5 } In the event of performing a bulk HRMC simulation instead of a slab, the cell must also be orthogonal in the z-axis and assumes that there is not vacuum space in the z-direction. If the difference between the lattice dimension in the z-direction and the structure thickness along z is greater than 1, the package will incorrectly assume that the cell is a slab and may perform erroneously. The Validators.coordination constraint should be used with only BulkCoordinationRange .","title":"Bulk vs slab cells"},{"location":"user_guide/bulk_vs_slab/#bulk-vs-slab-simulations","text":"pyHRMC is designed to handle bulk cells or slab cells in a vacuum. While the package will automatically detect the cell type and handle periodic boundary conditions, several considerations and limitations exist. For a slab cell, pyHRMC assumes that the vacuum space above and below the cell exist in the z-direction, and that the structure extends fully to the cell boundaries in the x and y directions. Additionally, the slab must be orthogonal to the z-axis for the package to correctly detect the cell thickness. When running a slab cell simulation and employing the Validators.coordination constraint, be sure to set constraints for SurfaceCoordinationRange and SurfaceDistance in addition to BulkCoordinationRange . For example: \"Coordination\": { \"BulkCoordinationRange\": { \"Al\": {\"Al\" : [0, 2], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": { \"Al\": {\"Al\": [0, 2], \"O\": [1, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 5 } In the event of performing a bulk HRMC simulation instead of a slab, the cell must also be orthogonal in the z-axis and assumes that there is not vacuum space in the z-direction. If the difference between the lattice dimension in the z-direction and the structure thickness along z is greater than 1, the package will incorrectly assume that the cell is a slab and may perform erroneously. The Validators.coordination constraint should be used with only BulkCoordinationRange .","title":"Bulk vs slab simulations"},{"location":"user_guide/nonhybrid_setup/","text":"Non-hybrid simulations (RMC) Traditional RMC simulations can also be performed with pyHRMC. It\u2019s important to note that traditional RMC is typically less accurate than HRMC, and for this reason, we don\u2019t recommend it. However, it can be useful in some cases, such as when a suitable force field is not available for energy calculations. In this case, empirical structural constraints are necessary to prevent the Monte Carlo algorithm from producing unphysical configurations. Coordination and distance constraints are available under the Validators class. To run an RMC simulation (with no energy constraint), use the following input files: runfile.py your_epdf.gr initial_structure.vasp The runfile must be configured to appropriately to avoid running features designing for HRMC. When instantiating the RMC class, set hybrid=False (defaults to True). Additionally, q_temp and init_temp arguments are not required for non-hybrid RMC (defaults to None): Below is an example of a non-hybrid RMC setup with no quenching of the error constraint parameter sigma : rmc = RMC( experimental_G_csv=\"al2o3_5nm_gr.txt\", sigma = 0.05, q_scatter = 1, hybrid= False ) When calling the run_rmc method, the configuration is the same as HRMC. However, we strongly suggest using additional validators to appropriately constrain the system.","title":"Non-hybrid simulations"},{"location":"user_guide/nonhybrid_setup/#non-hybrid-simulations-rmc","text":"Traditional RMC simulations can also be performed with pyHRMC. It\u2019s important to note that traditional RMC is typically less accurate than HRMC, and for this reason, we don\u2019t recommend it. However, it can be useful in some cases, such as when a suitable force field is not available for energy calculations. In this case, empirical structural constraints are necessary to prevent the Monte Carlo algorithm from producing unphysical configurations. Coordination and distance constraints are available under the Validators class. To run an RMC simulation (with no energy constraint), use the following input files: runfile.py your_epdf.gr initial_structure.vasp The runfile must be configured to appropriately to avoid running features designing for HRMC. When instantiating the RMC class, set hybrid=False (defaults to True). Additionally, q_temp and init_temp arguments are not required for non-hybrid RMC (defaults to None): Below is an example of a non-hybrid RMC setup with no quenching of the error constraint parameter sigma : rmc = RMC( experimental_G_csv=\"al2o3_5nm_gr.txt\", sigma = 0.05, q_scatter = 1, hybrid= False ) When calling the run_rmc method, the configuration is the same as HRMC. However, we strongly suggest using additional validators to appropriately constrain the system.","title":"Non-hybrid simulations (RMC)"},{"location":"user_guide/validator_selection/","text":"pyHRMC.validators Validators are used to impose physical constraints on the Monte Carlo algorithm and enforce the evolution of physically realistic structural configurations. In traditional RMC, these constraints are the sole avenue in imposing \"chemical knowledge\" on the simulation. In HRMC, the need for accurate and restrictive constraints are alleviated because the structure's energy is also used to determine whether to accept or reject a proposed step. Since no set of validators is universally applicable across systems, users must select values that are appropriate for their use case. SlabThickness \"SlabThickness\": {\"max_thickness\": float} When setting a SlabThickness constraint, a max_thickness value must be set. This is the max thickness that the simulation will allow a slab cell to reach in the z-direction (note that this is thickness, not the max Cartesian coordinate). This constraint should not be used when running bulk cell simulations, since cell length along z should be roughly equal to the thickness. Coordination \"Coordination\": { \"BulkCoordinationRange\": { \"species\": { \"species1\" : [int(min_coordination), int(max_coordination)], \"species2\": [int(min_coordination), int(max_coordination)], ... } ... }, \"SurfaceCoordinationRange\" = None, \"SurfaceDistance\" = None } For the BulkCoordinationRange and SurfaceCoordinationRange , the Coordination constraint expects a dictionary for each species type. Within each dictionary, a subdictionary with the minimum and maximum allowable coordination numbers should be included for each species type in the structure. This should look like a nested dictionary. Below is an example for alumina (Al and O species): \"BulkCoordinationRange\": { \"Al\": {\"Al\" : [0, 2], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} } The SurfaceDistance can be an integer or float and is used to differentiate surface and bulk atoms. This value is the distance from the top and bottom of the slab cell which contains the region of atoms that are constrained by SurfaceCoordiantionRange . All remaining atoms between these two surface regions are constrained by BulkCoordinationRange . DistancesCoordination \"DistancesCoordination\": { \"MinDistances\": { (\"species\", \"species\"): float, ... }, \"BulkCoordinationRange\": { \"species\": { \"species1\" : [int(min_coordination), int(max_coordination)], \"species2\": [int(min_coordination), int(max_coordination)], ... } ... }, \"SurfaceCoordinationRange\" = None \"SurfaceDistance\"= None } In addition to the same coordination check that is executed by the Coordination constraint, DistanceCoordination will conduct a check to determine if any interatomic distances are below the user-defined minimum distances. Distance cutoffs for this constrain should be defined pairwise for the species types. If any distances below the corresponding cutoff is found, the step will automatically be rejected. When checking the MinDistances, the program will recognize the pairwise combination regardless of order (e.g. (\"Al\", \"O\") is the same as (\"O\", \"Al\")). Below is an example for alumina (Al and O species): \"DistancesCoordination\": { \"MinDistances\": { (\"Al\", \"Al\"): 1.6, (\"Al\", \"O\"): 1.6, (\"O\", \"O\"): 1.8 }, \"BulkCoordinationRange\": { \"Al\": {\"Al\" : [0, 2], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": { \"Al\": {\"Al\": [0, 2], \"O\": [1, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 3 } If the same minimum distance can be applied to all element pairs, the SiteDistance constraint will be faster and can be used in conjunction with the Coordination constraint. SiteDistance \"SiteDistance\": { distance_cutoff = float } The SiteDistance constraint will uses the distance_matrix property from pymatgen to check all interatomic distances in the system against a single, universal minimum distance cutoff. If any interatomic distances are found to be less than the user-specified cutoff, the program will automatically reject the step. TargetDensity \"TargetDensity\": { \"target_density\": float, \"percent_allowance\": 0.05, \"check_slab\": True } The structure density is compared to the user-defined target density. If the density does not fall within the percent allowance of the target density (defaults to 5%), the step will automatically be rejected. If using a bulk cell, use \"check_slab\": False , otherwise this will default to True. Example An example of a run_rmc call with the SlabThickness and 'Coordination` validators in included in the documentation for runfile setup .","title":"Validator selection"},{"location":"user_guide/validator_selection/#pyhrmcvalidators","text":"Validators are used to impose physical constraints on the Monte Carlo algorithm and enforce the evolution of physically realistic structural configurations. In traditional RMC, these constraints are the sole avenue in imposing \"chemical knowledge\" on the simulation. In HRMC, the need for accurate and restrictive constraints are alleviated because the structure's energy is also used to determine whether to accept or reject a proposed step. Since no set of validators is universally applicable across systems, users must select values that are appropriate for their use case.","title":"pyHRMC.validators"},{"location":"user_guide/validator_selection/#slabthickness","text":"\"SlabThickness\": {\"max_thickness\": float} When setting a SlabThickness constraint, a max_thickness value must be set. This is the max thickness that the simulation will allow a slab cell to reach in the z-direction (note that this is thickness, not the max Cartesian coordinate). This constraint should not be used when running bulk cell simulations, since cell length along z should be roughly equal to the thickness.","title":"SlabThickness"},{"location":"user_guide/validator_selection/#coordination","text":"\"Coordination\": { \"BulkCoordinationRange\": { \"species\": { \"species1\" : [int(min_coordination), int(max_coordination)], \"species2\": [int(min_coordination), int(max_coordination)], ... } ... }, \"SurfaceCoordinationRange\" = None, \"SurfaceDistance\" = None } For the BulkCoordinationRange and SurfaceCoordinationRange , the Coordination constraint expects a dictionary for each species type. Within each dictionary, a subdictionary with the minimum and maximum allowable coordination numbers should be included for each species type in the structure. This should look like a nested dictionary. Below is an example for alumina (Al and O species): \"BulkCoordinationRange\": { \"Al\": {\"Al\" : [0, 2], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} } The SurfaceDistance can be an integer or float and is used to differentiate surface and bulk atoms. This value is the distance from the top and bottom of the slab cell which contains the region of atoms that are constrained by SurfaceCoordiantionRange . All remaining atoms between these two surface regions are constrained by BulkCoordinationRange .","title":"Coordination"},{"location":"user_guide/validator_selection/#distancescoordination","text":"\"DistancesCoordination\": { \"MinDistances\": { (\"species\", \"species\"): float, ... }, \"BulkCoordinationRange\": { \"species\": { \"species1\" : [int(min_coordination), int(max_coordination)], \"species2\": [int(min_coordination), int(max_coordination)], ... } ... }, \"SurfaceCoordinationRange\" = None \"SurfaceDistance\"= None } In addition to the same coordination check that is executed by the Coordination constraint, DistanceCoordination will conduct a check to determine if any interatomic distances are below the user-defined minimum distances. Distance cutoffs for this constrain should be defined pairwise for the species types. If any distances below the corresponding cutoff is found, the step will automatically be rejected. When checking the MinDistances, the program will recognize the pairwise combination regardless of order (e.g. (\"Al\", \"O\") is the same as (\"O\", \"Al\")). Below is an example for alumina (Al and O species): \"DistancesCoordination\": { \"MinDistances\": { (\"Al\", \"Al\"): 1.6, (\"Al\", \"O\"): 1.6, (\"O\", \"O\"): 1.8 }, \"BulkCoordinationRange\": { \"Al\": {\"Al\" : [0, 2], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": { \"Al\": {\"Al\": [0, 2], \"O\": [1, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 3 } If the same minimum distance can be applied to all element pairs, the SiteDistance constraint will be faster and can be used in conjunction with the Coordination constraint.","title":"DistancesCoordination"},{"location":"user_guide/validator_selection/#sitedistance","text":"\"SiteDistance\": { distance_cutoff = float } The SiteDistance constraint will uses the distance_matrix property from pymatgen to check all interatomic distances in the system against a single, universal minimum distance cutoff. If any interatomic distances are found to be less than the user-specified cutoff, the program will automatically reject the step.","title":"SiteDistance"},{"location":"user_guide/validator_selection/#targetdensity","text":"\"TargetDensity\": { \"target_density\": float, \"percent_allowance\": 0.05, \"check_slab\": True } The structure density is compared to the user-defined target density. If the density does not fall within the percent allowance of the target density (defaults to 5%), the step will automatically be rejected. If using a bulk cell, use \"check_slab\": False , otherwise this will default to True.","title":"TargetDensity"},{"location":"user_guide/validator_selection/#example","text":"An example of a run_rmc call with the SlabThickness and 'Coordination` validators in included in the documentation for runfile setup .","title":"Example"},{"location":"user_guide/getting_started/lammps_input/","text":"LAMMPS input and potential files In pyHRMC, the structural energy is computed for every atom hop with LAMMPS. LAMMPS requires input files that act as a \"to-do list\" for the program, including information about the structure, desired computes, and running LAMMPS. For more detailed documentation, please refer to the official LAMMPS documentation . Curently, pyHRMC requires three input files. In the future, this wil be modified to reduce the number of files to one. in.lmp Four sections are required for the in.lmp file: Initialization, Atom groups, Compute and outputs, and Run. Initialization: This is used to select the units for LAMMPS to use, read in the structure, and specify potential parameters. Because pyHRMC will automatically write a structure data file in the LAMMPS format, always include the following line: read_data data.lmp Additionally, if using a potential model trained from FLARE, follow instructions in their documentation to include this in the input script. pair_style flare pair_coeff * * lmp.flare Atom groups: Add the mass and element names. The numbering of the atom types must follow the order of atoms in the original structure file. mass {atom_type} {float} group {element_name} type {atom_type} Compute and outputs: Include commands to compute and print any additional desired variables. Any commands in this section are optional. The program will automatically extract the potential energy of the structure and dump the trajectory into the XDATCAR file, but additional desired outputs can be included here and dumped into a separate file. If using a FLARE potential, the uncertainty of the potential can be dumped on a per-atom basis. If the uncertainty is computed, LAMMPS can dump the trajectory in a file which can be used to visualize the uncertainty in OVITO. Detailed instructions can be found in this tutorial notebook . In the input script, include the following lines to compute the uncertainty-per-atom and the maximum atomic uncertainty and dump the uncertainty to a trajectory file called output.dump . compute unc all flare/std/atom L_inv_lmp.flare sparse_desc_lmp.flare compute MaxUnc all reduce max c_unc # Define the dump file and append to it dump dump_all all custom 1 output.dump id type x y z c_unc dump_modify dump_all append yes sort id While a thermo and thermo_style command can also be included, it is not very useful, given that the LAMMPS is called repeatedly in HRMC instead of running a single LAMMPS run over the entire simulation. Run: Run the LAMMPS code for 0 timesteps, meaning that it will only perform the desired computes and not perform any molecular dynamics # Run the simulation run 0 Example # Initialization atom_style atomic units metal boundary p p p atom_modify sort 0 0.0 newton on read_data data.lmp ### interactions pair_style flare pair_coeff * * s_lmp.flare # Atom groups mass 1 26.981539 mass 2 15.9994 group Al type 1 group O type 2 #Compute and outputs compute unc all flare/std/atom s_L_inv_lmp.flare s_sparse_desc_lmp.flare compute MaxUnc all reduce max c_unc thermo 1 thermo_style custom step pe ke etotal # Run the simulation run 0 in_init.lmp This script requires additional lines to save each step in a file called \"last_step.txt\" to allow LAMMPS to restart at the appropriate timestep. Add the following lines before the run command in the original in.lmp script: # Save the final timestep to a file variable last_step equal \"step\" shell echo ${last_step} > last_step.txt in_accept.lmp This script requires an additional line to read in the current timestep of the simulation. Add the following line before the run command in the original in.lmp script: # Read the last timestep from the file reset_timestep ${last_step}","title":"LAMMPS input files"},{"location":"user_guide/getting_started/lammps_input/#lammps-input-and-potential-files","text":"In pyHRMC, the structural energy is computed for every atom hop with LAMMPS. LAMMPS requires input files that act as a \"to-do list\" for the program, including information about the structure, desired computes, and running LAMMPS. For more detailed documentation, please refer to the official LAMMPS documentation . Curently, pyHRMC requires three input files. In the future, this wil be modified to reduce the number of files to one.","title":"LAMMPS input and potential files"},{"location":"user_guide/getting_started/lammps_input/#inlmp","text":"Four sections are required for the in.lmp file: Initialization, Atom groups, Compute and outputs, and Run. Initialization: This is used to select the units for LAMMPS to use, read in the structure, and specify potential parameters. Because pyHRMC will automatically write a structure data file in the LAMMPS format, always include the following line: read_data data.lmp Additionally, if using a potential model trained from FLARE, follow instructions in their documentation to include this in the input script. pair_style flare pair_coeff * * lmp.flare Atom groups: Add the mass and element names. The numbering of the atom types must follow the order of atoms in the original structure file. mass {atom_type} {float} group {element_name} type {atom_type} Compute and outputs: Include commands to compute and print any additional desired variables. Any commands in this section are optional. The program will automatically extract the potential energy of the structure and dump the trajectory into the XDATCAR file, but additional desired outputs can be included here and dumped into a separate file. If using a FLARE potential, the uncertainty of the potential can be dumped on a per-atom basis. If the uncertainty is computed, LAMMPS can dump the trajectory in a file which can be used to visualize the uncertainty in OVITO. Detailed instructions can be found in this tutorial notebook . In the input script, include the following lines to compute the uncertainty-per-atom and the maximum atomic uncertainty and dump the uncertainty to a trajectory file called output.dump . compute unc all flare/std/atom L_inv_lmp.flare sparse_desc_lmp.flare compute MaxUnc all reduce max c_unc # Define the dump file and append to it dump dump_all all custom 1 output.dump id type x y z c_unc dump_modify dump_all append yes sort id While a thermo and thermo_style command can also be included, it is not very useful, given that the LAMMPS is called repeatedly in HRMC instead of running a single LAMMPS run over the entire simulation. Run: Run the LAMMPS code for 0 timesteps, meaning that it will only perform the desired computes and not perform any molecular dynamics # Run the simulation run 0","title":"in.lmp"},{"location":"user_guide/getting_started/lammps_input/#example","text":"# Initialization atom_style atomic units metal boundary p p p atom_modify sort 0 0.0 newton on read_data data.lmp ### interactions pair_style flare pair_coeff * * s_lmp.flare # Atom groups mass 1 26.981539 mass 2 15.9994 group Al type 1 group O type 2 #Compute and outputs compute unc all flare/std/atom s_L_inv_lmp.flare s_sparse_desc_lmp.flare compute MaxUnc all reduce max c_unc thermo 1 thermo_style custom step pe ke etotal # Run the simulation run 0","title":"Example"},{"location":"user_guide/getting_started/lammps_input/#in_initlmp","text":"This script requires additional lines to save each step in a file called \"last_step.txt\" to allow LAMMPS to restart at the appropriate timestep. Add the following lines before the run command in the original in.lmp script: # Save the final timestep to a file variable last_step equal \"step\" shell echo ${last_step} > last_step.txt","title":"in_init.lmp"},{"location":"user_guide/getting_started/lammps_input/#in_acceptlmp","text":"This script requires an additional line to read in the current timestep of the simulation. Add the following line before the run command in the original in.lmp script: # Read the last timestep from the file reset_timestep ${last_step}","title":"in_accept.lmp"},{"location":"user_guide/getting_started/outputs/","text":"Outputs Once the HRMC simulation is started, pyHRMC will generate several files that it will continuously update during the simulation. These files contain data regarding the simulation and can be used for post-processing: error_plotting.txt With each acceptance of a batch of steps, the updated information will be appended to the error_plotting.txt file: {Iteration_number} {Error} {Energy_per_atom} {Sigma} {Temperature} {Maximum_uncertainty} Iteration number: the number of HRMC loops performed. To obtain the total number of steps, multiple this value by the number of processes used in each iteration Error: the MSE of the experimental and calculated ePDF Energy per atom: the units of energy will depend on the units specified in the LAMMPS input script. Sigma: this value is used to calculate the probability of accepting a step that increases the error (i.e. is the worse fit to experimental ePDF). Higher values correspond to an increased likelihood of acceptance, while a value of 0 means that such a step is never accepted. If a value of q_scatter < 1 is used, this value will gradually decrease over the course of the simulation. For details, see Background and Theory Temperature: this value is used to calculate the Boltzmann-type probability of accepting an energetically unfavorable step. Higher temperatures correspond to an increased probability of acceptance. If a value of q_temp < 1 is used, this value will gradually decrease over the course of the simulation. For details, see Background and Theory Max uncertainty: this is an optional output which can be set by including the appropriate lines in the LAMMPS input script . If turned on, the maximum uncertainty computed from the FLARE potential will be printed according to the dump_freq that is set during the creation of the RMC object. Otherwise, this column will be populated by zeroes. In the event of a non-hybrid simulation, error_plotting.txt will include the following information instead: {Iteration_number} {Error} {Sigma} output.vasp The most current structure in the POSCAR format. This file is overwritten every time an iteration of the HRMC loop is accepted. XDATCAR: A trajectory file of the simulation in the XDATCAR format. Dumped every iteration of the HRMC loop, and therefore every number of steps equal to the number of processes used. pdf.txt A text file of the calculated ePDF, which is overwritten with a frequency of dump_freq iterations. The file includes the radius (x) values followed by the G(r) (y) values. pdfs.png A plotted figure of the experimental vs. calculated ePDFs. This is plotted using the same data that is included in the pdf.txt file and overwritten at the same frequency, but is saved as a figure for easy viewing purposes. Other files Additionally, several files are created and used by HRMC during the simulation, but do not provide useful information to the user: {int}.lmp last_step.txt This files are used to maintain continuity between calls to LAMMPS and to distinguish the structures between processes.","title":"Understanding outputs"},{"location":"user_guide/getting_started/outputs/#outputs","text":"Once the HRMC simulation is started, pyHRMC will generate several files that it will continuously update during the simulation. These files contain data regarding the simulation and can be used for post-processing:","title":"Outputs"},{"location":"user_guide/getting_started/outputs/#error_plottingtxt","text":"With each acceptance of a batch of steps, the updated information will be appended to the error_plotting.txt file: {Iteration_number} {Error} {Energy_per_atom} {Sigma} {Temperature} {Maximum_uncertainty} Iteration number: the number of HRMC loops performed. To obtain the total number of steps, multiple this value by the number of processes used in each iteration Error: the MSE of the experimental and calculated ePDF Energy per atom: the units of energy will depend on the units specified in the LAMMPS input script. Sigma: this value is used to calculate the probability of accepting a step that increases the error (i.e. is the worse fit to experimental ePDF). Higher values correspond to an increased likelihood of acceptance, while a value of 0 means that such a step is never accepted. If a value of q_scatter < 1 is used, this value will gradually decrease over the course of the simulation. For details, see Background and Theory Temperature: this value is used to calculate the Boltzmann-type probability of accepting an energetically unfavorable step. Higher temperatures correspond to an increased probability of acceptance. If a value of q_temp < 1 is used, this value will gradually decrease over the course of the simulation. For details, see Background and Theory Max uncertainty: this is an optional output which can be set by including the appropriate lines in the LAMMPS input script . If turned on, the maximum uncertainty computed from the FLARE potential will be printed according to the dump_freq that is set during the creation of the RMC object. Otherwise, this column will be populated by zeroes. In the event of a non-hybrid simulation, error_plotting.txt will include the following information instead: {Iteration_number} {Error} {Sigma}","title":"error_plotting.txt"},{"location":"user_guide/getting_started/outputs/#outputvasp","text":"The most current structure in the POSCAR format. This file is overwritten every time an iteration of the HRMC loop is accepted.","title":"output.vasp"},{"location":"user_guide/getting_started/outputs/#xdatcar","text":"A trajectory file of the simulation in the XDATCAR format. Dumped every iteration of the HRMC loop, and therefore every number of steps equal to the number of processes used.","title":"XDATCAR:"},{"location":"user_guide/getting_started/outputs/#pdftxt","text":"A text file of the calculated ePDF, which is overwritten with a frequency of dump_freq iterations. The file includes the radius (x) values followed by the G(r) (y) values.","title":"pdf.txt"},{"location":"user_guide/getting_started/outputs/#pdfspng","text":"A plotted figure of the experimental vs. calculated ePDFs. This is plotted using the same data that is included in the pdf.txt file and overwritten at the same frequency, but is saved as a figure for easy viewing purposes.","title":"pdfs.png"},{"location":"user_guide/getting_started/outputs/#other-files","text":"Additionally, several files are created and used by HRMC during the simulation, but do not provide useful information to the user: {int}.lmp last_step.txt This files are used to maintain continuity between calls to LAMMPS and to distinguish the structures between processes.","title":"Other files"},{"location":"user_guide/getting_started/required_files/","text":"Getting Started List of input files Running a simulation with pyHRMC requires several input files that contain calculation parameters, experimental data, and an initial structure configuration. To begin, create a new directory with the following files: runfile.py your_epdf.gr initial_structure.vasp LAMMPS input files: in.lmp in_init.lmp in_accept.lmp FLARE force field model (optional) your_epdf.gr The experimental ePDF data to be used in the simulation must be prepared as a file with tabulated r and G(r) values that are separated by a comma. For example, this file might look like: r,gr 0.0125, 0 0.025, 0 0.0375, 0 0.05, 0 0.0625, 0 ... ... ... 9.9625, -0.0011 9.975, -0.00183 9.9875, -0.00237 10, -0.00271 initial_structure.vasp A structure file must be prepared in the POSCAR/VASP format for the HRMC simulation to use at a starting configuration of atoms. For a slab simulation, sufficient vacuum space must be inserted above and below the slab to simulate these surfaces. The initial structure file must include the correct number of atoms and stoichiometry that are to be simulated, since HRMC does not affect the composition of the simulated cell. Additionally, if performing a bulk simulation, the cell must also be configured with the correct density. In slab simulations, density may decrease to a minor degree, but the slab will not expand to fill the vacuum space in the z direction. Currently, cells must be orthogonal to the z axis to run correctly.","title":"Required files"},{"location":"user_guide/getting_started/required_files/#getting-started","text":"","title":"Getting Started"},{"location":"user_guide/getting_started/required_files/#list-of-input-files","text":"Running a simulation with pyHRMC requires several input files that contain calculation parameters, experimental data, and an initial structure configuration. To begin, create a new directory with the following files: runfile.py your_epdf.gr initial_structure.vasp LAMMPS input files: in.lmp in_init.lmp in_accept.lmp FLARE force field model (optional)","title":"List of input files"},{"location":"user_guide/getting_started/required_files/#your_epdfgr","text":"The experimental ePDF data to be used in the simulation must be prepared as a file with tabulated r and G(r) values that are separated by a comma. For example, this file might look like: r,gr 0.0125, 0 0.025, 0 0.0375, 0 0.05, 0 0.0625, 0 ... ... ... 9.9625, -0.0011 9.975, -0.00183 9.9875, -0.00237 10, -0.00271","title":"your_epdf.gr"},{"location":"user_guide/getting_started/required_files/#initial_structurevasp","text":"A structure file must be prepared in the POSCAR/VASP format for the HRMC simulation to use at a starting configuration of atoms. For a slab simulation, sufficient vacuum space must be inserted above and below the slab to simulate these surfaces. The initial structure file must include the correct number of atoms and stoichiometry that are to be simulated, since HRMC does not affect the composition of the simulated cell. Additionally, if performing a bulk simulation, the cell must also be configured with the correct density. In slab simulations, density may decrease to a minor degree, but the slab will not expand to fill the vacuum space in the z direction. Currently, cells must be orthogonal to the z axis to run correctly.","title":"initial_structure.vasp"},{"location":"user_guide/getting_started/runfile_setup/","text":"Runfile setup All calculation parameters are defined in runfile.py, which instantiates the RMC class before calling the run_rmc() method to perform the simulation. A runfile should begin with necessary imports: from pyHRMC.core.rmc import RMC import multiprocessing Creating RMC object To run a simulation, the user must first create a RMC class object with the required arguments. These arguments determine the quench rate of the error and energy constraints. rmc = RMC( experimental_G_csv=str(), sigma=float(), q_scatter=float(), q_temp=float(), init_temp=float(), dump_freq = 5000 ) experimental_G_csv: filename of experiment ePDF sigma: initial value of sigma, the value is used to calculate the probability of accepting a step that increases the error (i.e. is the worse fit to experimental ePDF). To allow proper convergence, this value should not start at zero, which means that steps that increase error are never accepted. Using sigma=0 for the entire simulation will prevent the structure sufficiently exploring the structural space to find a solution with a low error. For details, see Background and Theory q_scatter: quench rate for error constraint (rate of decreasing sigma). If a value of q_scatter < 1 is used, sigma will gradually decrease over the course of the simulation. q_temp: quench rate for energy constraint (rate of decreasing temperature). If a value of q_temp < 1 is used, this value will gradually decrease over the course of the simulation. init_temp: initial temperature, which is used to calculate the Boltzmann-type probability of accepting an energetically unfavorable step. The program will not quench the temperature below 100 K, so an init_temp below this value will remain unchanged regardless of the q_temp . For details, see Background and Theory dump_freq: the frequency at which to update the pdf.txt and pdfs.png files , as well as output the maximum atomic uncertainty as computed by LAMMPS from a FLARE potential. Defaults to every 5000 HRMC iterations The choice of sigma , init_temp , and their corresponding quenching rates q_scatter and q_temp is highly important to allow the simulation to properly converge. Many examples of simulations and their parameters used can be found in the literature, some of which have been listed in the references section . Calling the run_rmc() method To perform a simulation, use the run_rmc() method and further specify simulation parameters and constraints. rmc.run_rmc( num_processes=int(), initial_structure=str(), keV=int(), prdf_args={\u201cbin_size:float}, transformations={\u201cAtomHop\u201d:{}}, validators=dict(), charges=dict(), pdf_cutoff=float(), max_steps=int() ) num_processes: the number of processes to use in the simulation. If a serial simulation is desired, set to 1. If greater than 1, pyHRMC performs the simulation in iterations. In each iteration, a number of Monte Carlo steps equal to num_processes will be independently generated and validated in parallel. Accepted individual steps will then be merged and re-tested in a single structure, which constitutes one iteration. Therefore, the total number of steps will always be equal to num_processes x the number of completed iterations. This distinction is particularly important when selecting q_scatter and q_temp and interpreting output files. initial_structure: the filename of the structure file to use as an initial configuration. This file must be in a POSCAR/VASP format. The structure should have the correct stoichiometry, sincve HRMC does not affect the composition of the structure. keV: the accelerating voltage of the electron microsope used to capture scattering data prdf_args bin_size: the bin size of the computed PDFs, in angstroms. Default is 0.04 angstroms. transformations AtomHop: currently the only kind of transformation available in pyHRMC. This transformation creates a spherical grid of radius 1 Angstrom around an atom and selects a cell within the grid randomly. The coordinates of the selected cell are treated as the new coordinates of the atom. This transformer only moves one atom at a time, but this action can be parallelized for major speedups and yield structures with multiple moved atoms in a single step. validators: details on available validators can be found on the validator selection page. SlabThickness Coordination BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance DistancesCoordination MinDistances BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance SiteDistances TargetDensity charges: this is an optional argument that the user may use to bypass the built-in method of interpolating partial charges for each of the elements in the structure. Additionally, if users desire that no partial charges are used and neutral atoms are assumed, they may set the charge values to 0. If using this argument, follow the following format: ''' charges = { \"species1\": float(charge), \"species2\" = float(charge), ... } ''' pdf_cutoff: this is the distance, in Angstroms, below which will not be included in calculating the PDF error. The value will default to 1.6 Angstroms unless otherwise specified by the user. max_steps: maximum number of steps to perform in the simulation. If running in parallel, note that all atom transformations performed in parallel will be considered as a single step. Example An example runfile.py for a simulation of amorphous alumina is shown below: from pyhrmc.core.rmc import RMC if __name__ == \"__main__\": rmc = RMC(experimental_G_csv=\"al2o3_5nm_gr.txt\", sigma = 0.05, q_scatter = 1, q_temp = 0.999999995, init_temp = 1000) rmc.run_rmc( num_processes = 8, initial_structure=\"POSCAR_47A-d33\", keV=200, prdf_args={\"bin_size\": 0.04}, transformations={ \"AtomHop\": {} }, validators={ \"SlabThickness\": {\"max_thickness\": 47.4}, \"Coordination\": { \"BulkCoordinationRange\": {\"Al\": {\"Al\" : [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": {\"Al\": {\"Al\": [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 5 } }, max_steps= 1000000, )","title":"Runfile setup"},{"location":"user_guide/getting_started/runfile_setup/#runfile-setup","text":"All calculation parameters are defined in runfile.py, which instantiates the RMC class before calling the run_rmc() method to perform the simulation. A runfile should begin with necessary imports: from pyHRMC.core.rmc import RMC import multiprocessing","title":"Runfile setup"},{"location":"user_guide/getting_started/runfile_setup/#creating-rmc-object","text":"To run a simulation, the user must first create a RMC class object with the required arguments. These arguments determine the quench rate of the error and energy constraints. rmc = RMC( experimental_G_csv=str(), sigma=float(), q_scatter=float(), q_temp=float(), init_temp=float(), dump_freq = 5000 ) experimental_G_csv: filename of experiment ePDF sigma: initial value of sigma, the value is used to calculate the probability of accepting a step that increases the error (i.e. is the worse fit to experimental ePDF). To allow proper convergence, this value should not start at zero, which means that steps that increase error are never accepted. Using sigma=0 for the entire simulation will prevent the structure sufficiently exploring the structural space to find a solution with a low error. For details, see Background and Theory q_scatter: quench rate for error constraint (rate of decreasing sigma). If a value of q_scatter < 1 is used, sigma will gradually decrease over the course of the simulation. q_temp: quench rate for energy constraint (rate of decreasing temperature). If a value of q_temp < 1 is used, this value will gradually decrease over the course of the simulation. init_temp: initial temperature, which is used to calculate the Boltzmann-type probability of accepting an energetically unfavorable step. The program will not quench the temperature below 100 K, so an init_temp below this value will remain unchanged regardless of the q_temp . For details, see Background and Theory dump_freq: the frequency at which to update the pdf.txt and pdfs.png files , as well as output the maximum atomic uncertainty as computed by LAMMPS from a FLARE potential. Defaults to every 5000 HRMC iterations The choice of sigma , init_temp , and their corresponding quenching rates q_scatter and q_temp is highly important to allow the simulation to properly converge. Many examples of simulations and their parameters used can be found in the literature, some of which have been listed in the references section .","title":"Creating RMC object"},{"location":"user_guide/getting_started/runfile_setup/#calling-the-run_rmc-method","text":"To perform a simulation, use the run_rmc() method and further specify simulation parameters and constraints. rmc.run_rmc( num_processes=int(), initial_structure=str(), keV=int(), prdf_args={\u201cbin_size:float}, transformations={\u201cAtomHop\u201d:{}}, validators=dict(), charges=dict(), pdf_cutoff=float(), max_steps=int() ) num_processes: the number of processes to use in the simulation. If a serial simulation is desired, set to 1. If greater than 1, pyHRMC performs the simulation in iterations. In each iteration, a number of Monte Carlo steps equal to num_processes will be independently generated and validated in parallel. Accepted individual steps will then be merged and re-tested in a single structure, which constitutes one iteration. Therefore, the total number of steps will always be equal to num_processes x the number of completed iterations. This distinction is particularly important when selecting q_scatter and q_temp and interpreting output files. initial_structure: the filename of the structure file to use as an initial configuration. This file must be in a POSCAR/VASP format. The structure should have the correct stoichiometry, sincve HRMC does not affect the composition of the structure. keV: the accelerating voltage of the electron microsope used to capture scattering data prdf_args bin_size: the bin size of the computed PDFs, in angstroms. Default is 0.04 angstroms. transformations AtomHop: currently the only kind of transformation available in pyHRMC. This transformation creates a spherical grid of radius 1 Angstrom around an atom and selects a cell within the grid randomly. The coordinates of the selected cell are treated as the new coordinates of the atom. This transformer only moves one atom at a time, but this action can be parallelized for major speedups and yield structures with multiple moved atoms in a single step. validators: details on available validators can be found on the validator selection page. SlabThickness Coordination BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance DistancesCoordination MinDistances BulkCoordinationRange SurfaceCoordinationRange SurfaceDistance SiteDistances TargetDensity charges: this is an optional argument that the user may use to bypass the built-in method of interpolating partial charges for each of the elements in the structure. Additionally, if users desire that no partial charges are used and neutral atoms are assumed, they may set the charge values to 0. If using this argument, follow the following format: ''' charges = { \"species1\": float(charge), \"species2\" = float(charge), ... } ''' pdf_cutoff: this is the distance, in Angstroms, below which will not be included in calculating the PDF error. The value will default to 1.6 Angstroms unless otherwise specified by the user. max_steps: maximum number of steps to perform in the simulation. If running in parallel, note that all atom transformations performed in parallel will be considered as a single step.","title":"Calling the run_rmc() method"},{"location":"user_guide/getting_started/runfile_setup/#example","text":"An example runfile.py for a simulation of amorphous alumina is shown below: from pyhrmc.core.rmc import RMC if __name__ == \"__main__\": rmc = RMC(experimental_G_csv=\"al2o3_5nm_gr.txt\", sigma = 0.05, q_scatter = 1, q_temp = 0.999999995, init_temp = 1000) rmc.run_rmc( num_processes = 8, initial_structure=\"POSCAR_47A-d33\", keV=200, prdf_args={\"bin_size\": 0.04}, transformations={ \"AtomHop\": {} }, validators={ \"SlabThickness\": {\"max_thickness\": 47.4}, \"Coordination\": { \"BulkCoordinationRange\": {\"Al\": {\"Al\" : [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceCoordinationRange\": {\"Al\": {\"Al\": [0, 1], \"O\": [2, 7]}, \"O\": {\"Al\": [1, 4], \"O\": [0, 1]} }, \"SurfaceDistance\": 5 } }, max_steps= 1000000, )","title":"Example"}]}